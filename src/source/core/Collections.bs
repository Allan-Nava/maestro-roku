import "pkg:/source/core/Utils.bs"

namespace mc.collections

  ' /**
  '  * @member mapArray
  '  * @memberof module:Collections
  '  * @instance
  '  * @function
  '  * @description returns an array with items mapped by the mapper
  '  * @param {array} array of items to map
  '  * @param {class} mapper, function (transform):outputType, or class with a transform(item):outputType function
  '  * @returns {outputType} items mapped by the mapper
  '  */
  function mapArray(array as mc.types.array, mapper as mc.collections.BaseMapper)
    items = []
    if array <> invalid
      isClass = isClass(mapper)
      for each item in array
        if isClass
          transformed = mapper.transform(item)
          if transformed <> invalid
            items.push(transformed)
          end if
        else
          transformed = mapper(item)
          if transformed <> invalid
            items.push(transformed)
          end if
        end if
      end for
    end if
    return items
  end function

  function getItemAtOffset(array as mc.types.array, item as dynamic, offset as integer)
    if array = invalid or array.count() = 0
      return invalid
    end if
    index = mc.collections.getArrayIndex(array, item)
    return array[mc.clamp(index + offset, 0, array.count() - 1)]
  end function

  function getArrayIndex(array as mc.types.array, item as dynamic)
    if array = invalid or array.count() = 0
      return -1
    end if

    for i = 0 to array.count() - 1
      if array[i] = item
        return i
      end if
    end for
    return -1
  end function


  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ mappers
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  class BaseMapper
    function transform(item as dynamic)
    end function
  end class

  class CallFuncMapper extends mc.collections.BaseMapper
    function new(funcName as string, args as mc.types.assocarray)
      super()
      m.funcName = funcName
      m.args = args
    end function

    override function transform(item as dynamic)
      if item = invalid
        return invalid
      end if
      return item.callFunc(m.funcName, m.args)
    end function
  end class

  class FuncMapper extends mc.collections.BaseMapper
    function new(funcName as string)
      super()
      m.funcName = funcName
    end function

    override function transform(item as dynamic)
      if item = invalid
        return invalid
      end if
      if item[m.funcName] = invalid
        return invalid
      end if
      return item[m.funcName]()
    end function
  end class

  class FieldMapper extends mc.collections.BaseMapper
    function new(fieldName as string)
      super()
      m.fieldName = fieldName
    end function

    override function transform(item as dynamic)
      if item = invalid
        return invalid
      end if
      return item[m.fieldName]
    end function
  end class

  ' /**
  '  * @member filterArray
  '  * @memberof module:Collections
  '  * @instance
  '  * @function
  '  * @description returns an array with items that match the filter predicate
  '  * @param {array} array of items to filter
  '  * @param {class} predicate, function (item):bool, or class with a isMatch(item):bool function
  '  * @returns {boolean} items that match the predicate
  '  */
  function filterArray(array as mc.types.array, predicate as dynamic)
    items = []
    if array <> invalid
      isClass = isClass(predicate)
      for each item in array
        if (isClass and predicate.isMatch(item)) or (not isClass and predicate(item))
          items.push(item)
        end if
      end for
    end if
    return items
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ filter predicates
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  class AbstractPredicate
    function isMatch(item as dynamic) as boolean
      return false
    end function
  end class

  class ValuePredicate extends mc.collections.AbstractPredicate
    function new(expected as dynamic)
      super()
      m.expected = expected
    end function

    override function isMatch(item as dynamic) as boolean
      return item = m.expected
    end function
  end class

  class FieldPredicate extends mc.collections.AbstractPredicate
    function new(fieldName as string, expected as dynamic)
      super()
      m.fieldName = fieldName
      m.expected = expected
    end function

    override function isMatch(item as dynamic) as boolean
      if item = invalid
        return false
      end if
      return item[m.fieldName] = m.expected
    end function
  end class

  class FuncPredicate
    function new(funcName as string, expected as dynamic)
      m.funcName = funcName
      m.expected = expected
    end function

    function isMatch(item as dynamic) as boolean
      if item = invalid
        return false
      end if
      if item[m.funcName] = invalid
        return false
      end if
      compareTo = item[m.funcName]()
      return compareTo = m.expected
    end function
  end class

  class CallFuncPredicate extends mc.collections.AbstractPredicate
    function new(funcName as string, args as mc.types.assocarray, expected as dynamic)
      super()
      m.funcName = funcName
      m.args = args
      m.expected = expected
    end function

    override function isMatch(item as dynamic) as boolean
      if item = invalid
        return false
      end if
      compareTo = item.callFunc(m.funcName, m.args)
      return m.expected = compareTo
    end function
  end class

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ basic utils
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  function arrayContains(array as mc.types.array, value as dynamic) as boolean
    for each item in array
      if item = value
        return true
      end if
    end for
    return false
  end function

end namespace
