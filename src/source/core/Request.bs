import "pkg:/source/core/Utils.bs"
import "pkg:/source/roku_modules/log/LogMixin.brs"
import "pkg:/source/core/NetResponse.bs"

'adapted from https://github.com/bvisin/roku-requests

namespace mc.net
  @strict
  class Request
    private log

    function new()
      m.log = new log.Logger("Request")
    end function
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ public API
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function get(url as string, params = invalid as mc.types.assocarray, headers = invalid as mc.types.assocarray, otherArgs = invalid as mc.types.assocarray)
      return m.executeRequest("GET", url, params, headers, otherArgs)
    end function

    function post(url as string, params = invalid as mc.types.assocarray, headers = invalid as mc.types.assocarray, otherArgs = invalid as mc.types.assocarray)
      return m.executeRequest("POST", url, params, headers, otherArgs)
    end function

    function delete(url as string, params = invalid as mc.types.assocarray, headers = invalid as mc.types.assocarray, otherArgs = invalid as mc.types.assocarray)
      return m.executeRequest("DELETE", url, params, headers, otherArgs)
    end function

    function put(url as string, params = invalid as mc.types.assocarray, headers = invalid as mc.types.assocarray, otherArgs = invalid as mc.types.assocarray)
      return m.executeRequest("PUT", url, params, headers, otherArgs)
    end function

    function executeRequest(method as string, url as string, params = invalid as mc.types.assocarray, headers = invalid as mc.types.assocarray, otherArgs = invalid as mc.types.assocarray)

      if mc.isAACompatible(otherArgs)
        args = otherArgs
      else
        args = {}
      end if

      if mc.isAACompatible(params)
        args.params = params
      else if params <> invalid
        m.log.error("received illegal headers type", type(headers))
      end if

      if mc.isAACompatible(headers)
        args.headers = headers
      else if headers <> invalid
        m.log.error("received illegal headers type", type(headers))
      end if

      return m.request(method, url, args)
    end function

    private function request(method as string, url as string, args as object)
      _params = {}
      _headers = {}
      _data = invalid
      _json = invalid
      _timeout = 30000
      _retryCount = 0
      _verify = "common:/certs/ca-bundle.crt"
      if args <> invalid and type(args) = "roAssociativeArray"
        if args.params <> invalid and type(args.params) = "roAssociativeArray"
          _params = args.params
        end if
        if args.headers <> invalid and type(args.headers) = "roAssociativeArray"
          _headers = args.headers
        end if
        if args.data <> invalid and (type(args.data) = "String" or type(args.data) = "roString")
          _data = args.data
        end if
        if args.json <> invalid and type(args.json) = "roAssociativeArray"
          _json = FormatJson(args.json)
        end if
        if args.timeout <> invalid and (type(args.timeout) = "Integer" or type(args.timeout) = "roInteger")
          _timeout = args.timeout
        end if
        if args.retryCount <> invalid and (type(args.retryCount) = "Integer" or type(args.retryCount) = "roInteger")
          _retryCount = args.retryCount
        end if
        if args.verify <> invalid and (type(args.verify) = "String" or type(args.verify) = "roString")
          _verify = args.verify
        end if
      end if
      requestHeaders = new mc.net.headers()
      requestHeaders.addHeadersAA(_headers)
      requestQueryString = new mc.net.queryString()
      requestQueryString.addParamsAA(_params)
      if _data <> invalid
        data = _data
      else if _json <> invalid
        data = _json
        requestHeaders.addHeader("Content-Type", "application/json")
      else
        data = ""
      end if
      url = requestQueryString.append(url)
      headers = requestHeaders._headers
      response = mc.net.execute(method, url, headers, data, _timeout, _retryCount, _verify)
      return response
    end function

  end class

  function execute(method as string, url as string, headers as mc.types.assocarray, data as mc.types.assocarray, timeout as float, retryCount as integer, verify as string)
    transfer = mc.net.createUrlTransfer(true, true, verify)
    transfer.setUrl(url)
    transfer.setHeaders(headers)
    ? "[http] ------ START HTTP REQUEST ------"
    ? "[http] URL:", transfer.getURL()
    ? "[http] Timeout= ", timeout
    ? "[http] Headers: ", headers
    responseEvent = invalid
    requestDetails = {
      timesTried: 0,
    }

    while retryCount >= 0
      retryCount = retryCount - 1
      requestDetails.timesTried = requestDetails.timesTried + 1
      ? "[http] Method: ", method

      if method = "POST"
        sent = transfer.asyncPostFromString(data)

      else if method = "GET"
        sent = transfer.asyncGetToString()

      else if method = "HEAD"
        sent = transfer.asyncHead()

      else
        transfer.setRequest(method)
        sent = transfer.asyncPostFromString(data)
      end if

      if sent = true
        event = wait(timeout, transfer.getPort())

        if type(event) = "roUrlEvent"
          responseEvent = event
          responseCode = event.getResponseCode()
          ? "[http] Response Code", responseCode

          if responseCode > 0 and responseCode < 400
            exit while

          else
            ? "[http] Bad response", responseCode
            ? "[http] Will Retry ", retryCount
          end if

        else
          ? "[http] Event Timed Out"
          transfer.asyncCancel()
          timeout = timeout * 2
          ? "[http] Timeout=", timeout
        end if
      end if
    end while

    ? "[http] ------ END HTTP REQUEST ------"
    return new mc.net.NetResponse(transfer, responseEvent, requestDetails)
  end function

  @strict
  class Headers
    private _headers = {}

    function new()
    end function

    function addHeader(key as string, value as string)
      m._headers[key] = value
    end function

    function addHeadersAA(headers as object)
      m._headers.append(headers)
    end function
  end class

  @strict
  class QueryString
    private _transfer = createObject("roUrlTransfer")
    private _qs_array = []

    function new()
    end function
    function addString(params as string)
      if params.instr("&")
        split_params = params.split("&")
        for each param in split_params
          if param.instr("=")
            split_param = param.split("=")
            m.addParamKeyValue(split_param[0], split_param[1])
          else
            m.addParamKeyValue(param, "")
          end if
        end for
      else if params.instr("=")
        split_params = params.split("=")
        m.addParamKeyValue(split_params[0], split_params[1])
      else
        m.addParamKeyValue(params, "")
      end if
    end function

    function addParamKeyValue(param as string, key as string)
      m._qs_array.push([param, key])
    end function

    function addParamsAA(params as object)
      for each item in params.items()
        m.addParamKeyValue(item.key, item.value)
      end for
    end function

    function addParamsArray(params as object)
      if params.count() > 0
        for each item in params
          if item.count() > 1
            m.addParamKeyValue(item[0], item[1])
          else if item.count() > 0
            m.addParamKeyValue(item[0], "")
          end if
        end for
      end if
    end function

    function build() as string
      output = ""
      c = 0
      for each qs in m._qs_array
        if c = 0
          output = qs[0] + "=" + m._transfer.escape(qs[1])
        else
          output = output + "&" + qs[0] + "=" + m._transfer.escape(qs[1])
        end if
        c += 1
      end for
      return output
    end function

    function append(url as string) as string
      if m._qs_array.count() > 0
        if url.instr("?")
          if url.right(1) = "?"
            return url + m.build()
          else
            return url + "&" + m.build()
          end if
        else
          return url + "?" + m.build()
        end if
      end if
      return url
    end function
  end class

  function createUrlTransfer(enableEncodings as boolean, retainBodyOnError as boolean, verify as string)
    _transfer = createObject("roUrlTransfer")
    _transfer.setPort(createObject("roMessagePort"))
    _transfer.enableEncodings(enableEncodings)
    _transfer.retainBodyOnError(retainBodyOnError)
    if verify <> ""
      _transfer.setCertificatesFile(verify)
      _transfer.initClientCertificates()
    end if
    return _transfer
  end function


end namespace
